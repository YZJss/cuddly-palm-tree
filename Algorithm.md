# 【算法图解】笔记
#### 二分查找
```
def binary_search(list,item):
    low = 0
    high = len(list)-1
    
    while low <= high:
        mid = (low + high)
        guess = list[mid]
        if guess == item:
            return mid
        elif guess > item:
            high = mid - 1
        else:
            low = mid + 1
    return None

```
一般来说 对于包括n个元素的列表，用二分查找最多需要log n(以2为底)步，而简单查找最多需要n步。

#### 大O表示法
大O表示法 指的并非是以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。
* O(log n) 对数时间 比如二分查找
* O(n) 线性时间 比如简单查找
* O(n*log n) 快速排序
* O(n*n) 选择排序
* O(n!) 旅行商问题  
#### 小结  
* 二分查找的速度比简单查找快得多
* O(log n) 比 O(n)快。需要搜索的元素越多，前者比后者就越快的越多。
* 算法运行时间并不以秒为单位。
* 算法运行时间是从其增速的角度度量的
* 算法运行时间用大O表示法表示。
***
#### 选择排序
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。  
例: 将一个音乐播放列表按播放次数从多到少的顺序排列。  
解: 遍历这个列表，找出播放最多的歌曲，并将歌曲添加到一个新列表，直到全部待排序的数据元素排完。
```
def findSmallest(arr):
    samllest = arr[0]
    smallest_index = 0
    for i in range(1,len(arr)):
        if arr[i] < smallest:
            smallest_index = i
    return smallest_index
    
def selectionSort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = findSmallest(arr)
        newArr.append(arr.pop(smallest))
    return newArr
```
#### 数组和链表
##### 数组的特点
* 在内存中，数组是一块连续的区域。
* 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。
* 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。
* 随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
* 不利于扩展，数组定义的空间不够时要重新定义数组。
##### 链表的特点
* 在内存中可以存在任何地方，不要求连续。
* 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。
* 增加数据和删除数据很容易。
* 查找数据时效率低，因为不具有随机访问性。
* 不指定大小，扩展方便。链表大小不用定义，数据随意增删。

下面是常见数组和链表的运行时间

| |数组|链表|
|:---|:---|:---|
|读取|O(1)|O(n)|
|插入|O(n)|O(1)|
|删除|O(n)|O(1)|

O(n) = 线性时间  
O(1) = 常量时间
#### 小结
* 需要存储多个元素时，可使用数组或链表。
* 数组的元素都在一起
* 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
* 数组的读取速度很快，链表的插入和删除速度很快。
* 在同一个数组中，所有元素的类型必须相同（都为int double等）。
***
#### 递归
程序调用自身的编程技巧称为递归（recursion）。
```
def countdown(i):
    print(i)
    countdown(i-1)
```
输出3...2...1...0...-1...-2...  
会导致无限循环，所以编写递归函数时，必须告诉它何时停止递归。正因为如此，每个函数都有俩部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不在调用自己，从而避免形成无限循环。  
```
def countdown(i):
    print(i)
    if i <= 0:  #基线条件
        return
    else:       #递归条件
    countdown(i-1)
```
#### 栈
栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。  
比如**一叠便条**插入待办事项放在最前面；读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有俩种操作：压入（插入）和弹出（删除并读取）。  
#### 小结
* 递归指的是调用自己的函数。
* 每个递归函数都有俩个条件：基准条件和递归条件。
* 栈有俩种操作：压入和弹出。
* 所有函数调用都进入调用栈。
* 调用栈可能很长，这将占用大量的内存。
***

